// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.9
// 	protoc        v3.21.12
// source: clirpc/barter_backup_client.proto

package clirpc

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type ContractState int32

const (
	// NOT_STARTED means the operation has not begun.
	ContractState_NOT_STARTED ContractState = 0
	// CONNECTING_TO_PEER means we are connecting to the peer.
	ContractState_CONNECTING_TO_PEER ContractState = 1
	// PROPOSING_CONTRACT means we are proposing a contract to the peer.
	ContractState_PROPOSING_CONTRACT ContractState = 2
	// PEER_REFUSED means the peer refused to form or renew a contract.
	ContractState_PEER_REFUSED ContractState = 3
	// SYNCING_CONTENTS means we and the peer are downloading data or
	// each other.
	ContractState_SYNCING_CONTENTS ContractState = 4
	// CHECKING_CONTENTS means we are verifying stored content.
	ContractState_CHECKING_CONTENTS ContractState = 5
	// OUR_CONTENT_REVISION_MISSING means our content revision is missing on
	// the peer.
	ContractState_OUR_CONTENT_REVISION_MISSING ContractState = 6
	// INVALID_CONTENT_RETURNED means the peer returned invalid content when
	// we were checking it.
	ContractState_INVALID_CONTENT_RETURNED ContractState = 7
	// COMPLETED means the operation finished successfully.
	ContractState_COMPLETED ContractState = 8
)

// Enum value maps for ContractState.
var (
	ContractState_name = map[int32]string{
		0: "NOT_STARTED",
		1: "CONNECTING_TO_PEER",
		2: "PROPOSING_CONTRACT",
		3: "PEER_REFUSED",
		4: "SYNCING_CONTENTS",
		5: "CHECKING_CONTENTS",
		6: "OUR_CONTENT_REVISION_MISSING",
		7: "INVALID_CONTENT_RETURNED",
		8: "COMPLETED",
	}
	ContractState_value = map[string]int32{
		"NOT_STARTED":                  0,
		"CONNECTING_TO_PEER":           1,
		"PROPOSING_CONTRACT":           2,
		"PEER_REFUSED":                 3,
		"SYNCING_CONTENTS":             4,
		"CHECKING_CONTENTS":            5,
		"OUR_CONTENT_REVISION_MISSING": 6,
		"INVALID_CONTENT_RETURNED":     7,
		"COMPLETED":                    8,
	}
)

func (x ContractState) Enum() *ContractState {
	p := new(ContractState)
	*p = x
	return p
}

func (x ContractState) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ContractState) Descriptor() protoreflect.EnumDescriptor {
	return file_clirpc_barter_backup_client_proto_enumTypes[0].Descriptor()
}

func (ContractState) Type() protoreflect.EnumType {
	return &file_clirpc_barter_backup_client_proto_enumTypes[0]
}

func (x ContractState) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ContractState.Descriptor instead.
func (ContractState) EnumDescriptor() ([]byte, []int) {
	return file_clirpc_barter_backup_client_proto_rawDescGZIP(), []int{0}
}

type UnlockRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// main_password is the main password used to derive the master secret.
	MainPassword  string `protobuf:"bytes,1,opt,name=main_password,json=mainPassword,proto3" json:"main_password,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UnlockRequest) Reset() {
	*x = UnlockRequest{}
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UnlockRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UnlockRequest) ProtoMessage() {}

func (x *UnlockRequest) ProtoReflect() protoreflect.Message {
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UnlockRequest.ProtoReflect.Descriptor instead.
func (*UnlockRequest) Descriptor() ([]byte, []int) {
	return file_clirpc_barter_backup_client_proto_rawDescGZIP(), []int{0}
}

func (x *UnlockRequest) GetMainPassword() string {
	if x != nil {
		return x.MainPassword
	}
	return ""
}

type UnlockResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UnlockResponse) Reset() {
	*x = UnlockResponse{}
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UnlockResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UnlockResponse) ProtoMessage() {}

func (x *UnlockResponse) ProtoReflect() protoreflect.Message {
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UnlockResponse.ProtoReflect.Descriptor instead.
func (*UnlockResponse) Descriptor() ([]byte, []int) {
	return file_clirpc_barter_backup_client_proto_rawDescGZIP(), []int{1}
}

type Peer struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// onion_service_id is the Tor onion service identifier of the peer.
	OnionServiceId string `protobuf:"bytes,1,opt,name=onion_service_id,json=onionServiceId,proto3" json:"onion_service_id,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *Peer) Reset() {
	*x = Peer{}
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Peer) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Peer) ProtoMessage() {}

func (x *Peer) ProtoReflect() protoreflect.Message {
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Peer.ProtoReflect.Descriptor instead.
func (*Peer) Descriptor() ([]byte, []int) {
	return file_clirpc_barter_backup_client_proto_rawDescGZIP(), []int{2}
}

func (x *Peer) GetOnionServiceId() string {
	if x != nil {
		return x.OnionServiceId
	}
	return ""
}

type ConnectPeerRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// peer is the peer to add to the list of known peers.
	Peer          *Peer `protobuf:"bytes,1,opt,name=peer,proto3" json:"peer,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ConnectPeerRequest) Reset() {
	*x = ConnectPeerRequest{}
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ConnectPeerRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConnectPeerRequest) ProtoMessage() {}

func (x *ConnectPeerRequest) ProtoReflect() protoreflect.Message {
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConnectPeerRequest.ProtoReflect.Descriptor instead.
func (*ConnectPeerRequest) Descriptor() ([]byte, []int) {
	return file_clirpc_barter_backup_client_proto_rawDescGZIP(), []int{3}
}

func (x *ConnectPeerRequest) GetPeer() *Peer {
	if x != nil {
		return x.Peer
	}
	return nil
}

type ConnectPeerResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ConnectPeerResponse) Reset() {
	*x = ConnectPeerResponse{}
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ConnectPeerResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConnectPeerResponse) ProtoMessage() {}

func (x *ConnectPeerResponse) ProtoReflect() protoreflect.Message {
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConnectPeerResponse.ProtoReflect.Descriptor instead.
func (*ConnectPeerResponse) Descriptor() ([]byte, []int) {
	return file_clirpc_barter_backup_client_proto_rawDescGZIP(), []int{4}
}

type ConnectedPeersRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ConnectedPeersRequest) Reset() {
	*x = ConnectedPeersRequest{}
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ConnectedPeersRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConnectedPeersRequest) ProtoMessage() {}

func (x *ConnectedPeersRequest) ProtoReflect() protoreflect.Message {
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConnectedPeersRequest.ProtoReflect.Descriptor instead.
func (*ConnectedPeersRequest) Descriptor() ([]byte, []int) {
	return file_clirpc_barter_backup_client_proto_rawDescGZIP(), []int{5}
}

type ConnectedPeersResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// connected_peers contains the list of connected online peers.
	ConnectedPeers []*Peer `protobuf:"bytes,1,rep,name=connected_peers,json=connectedPeers,proto3" json:"connected_peers,omitempty"`
	// online_not_connected_peers contains the list of peers we believe are
	// online, but we are not connected to them now.
	OnlineNotConnectedPeers []*Peer `protobuf:"bytes,2,rep,name=online_not_connected_peers,json=onlineNotConnectedPeers,proto3" json:"online_not_connected_peers,omitempty"`
	// offline_peers contains the list of known offline peers.
	OfflinePeers  []*Peer `protobuf:"bytes,3,rep,name=offline_peers,json=offlinePeers,proto3" json:"offline_peers,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ConnectedPeersResponse) Reset() {
	*x = ConnectedPeersResponse{}
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ConnectedPeersResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConnectedPeersResponse) ProtoMessage() {}

func (x *ConnectedPeersResponse) ProtoReflect() protoreflect.Message {
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConnectedPeersResponse.ProtoReflect.Descriptor instead.
func (*ConnectedPeersResponse) Descriptor() ([]byte, []int) {
	return file_clirpc_barter_backup_client_proto_rawDescGZIP(), []int{6}
}

func (x *ConnectedPeersResponse) GetConnectedPeers() []*Peer {
	if x != nil {
		return x.ConnectedPeers
	}
	return nil
}

func (x *ConnectedPeersResponse) GetOnlineNotConnectedPeers() []*Peer {
	if x != nil {
		return x.OnlineNotConnectedPeers
	}
	return nil
}

func (x *ConnectedPeersResponse) GetOfflinePeers() []*Peer {
	if x != nil {
		return x.OfflinePeers
	}
	return nil
}

// File represents a single user-provided file that participates in forming
// the current content blob.
type File struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name is an arbitrary identifier shown to the user (for example,
	// a filename).
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// data is the raw file bytes.
	Data          []byte `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *File) Reset() {
	*x = File{}
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *File) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*File) ProtoMessage() {}

func (x *File) ProtoReflect() protoreflect.Message {
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use File.ProtoReflect.Descriptor instead.
func (*File) Descriptor() ([]byte, []int) {
	return file_clirpc_barter_backup_client_proto_rawDescGZIP(), []int{7}
}

func (x *File) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *File) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

type SetFileRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// file is the file to add or update in the current content set.
	File          *File `protobuf:"bytes,1,opt,name=file,proto3" json:"file,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SetFileRequest) Reset() {
	*x = SetFileRequest{}
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SetFileRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SetFileRequest) ProtoMessage() {}

func (x *SetFileRequest) ProtoReflect() protoreflect.Message {
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SetFileRequest.ProtoReflect.Descriptor instead.
func (*SetFileRequest) Descriptor() ([]byte, []int) {
	return file_clirpc_barter_backup_client_proto_rawDescGZIP(), []int{8}
}

func (x *SetFileRequest) GetFile() *File {
	if x != nil {
		return x.File
	}
	return nil
}

type SetFileResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SetFileResponse) Reset() {
	*x = SetFileResponse{}
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SetFileResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SetFileResponse) ProtoMessage() {}

func (x *SetFileResponse) ProtoReflect() protoreflect.Message {
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SetFileResponse.ProtoReflect.Descriptor instead.
func (*SetFileResponse) Descriptor() ([]byte, []int) {
	return file_clirpc_barter_backup_client_proto_rawDescGZIP(), []int{9}
}

type GetFileRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name is the name of the file to fetch from the current content.
	Name          string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetFileRequest) Reset() {
	*x = GetFileRequest{}
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetFileRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetFileRequest) ProtoMessage() {}

func (x *GetFileRequest) ProtoReflect() protoreflect.Message {
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetFileRequest.ProtoReflect.Descriptor instead.
func (*GetFileRequest) Descriptor() ([]byte, []int) {
	return file_clirpc_barter_backup_client_proto_rawDescGZIP(), []int{10}
}

func (x *GetFileRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

type GetFileResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// file is the requested file from the current content set.
	File          *File `protobuf:"bytes,1,opt,name=file,proto3" json:"file,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetFileResponse) Reset() {
	*x = GetFileResponse{}
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetFileResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetFileResponse) ProtoMessage() {}

func (x *GetFileResponse) ProtoReflect() protoreflect.Message {
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetFileResponse.ProtoReflect.Descriptor instead.
func (*GetFileResponse) Descriptor() ([]byte, []int) {
	return file_clirpc_barter_backup_client_proto_rawDescGZIP(), []int{11}
}

func (x *GetFileResponse) GetFile() *File {
	if x != nil {
		return x.File
	}
	return nil
}

type ListFilesRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListFilesRequest) Reset() {
	*x = ListFilesRequest{}
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListFilesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListFilesRequest) ProtoMessage() {}

func (x *ListFilesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListFilesRequest.ProtoReflect.Descriptor instead.
func (*ListFilesRequest) Descriptor() ([]byte, []int) {
	return file_clirpc_barter_backup_client_proto_rawDescGZIP(), []int{12}
}

type ListFilesResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name contains names of files that form the most recent content blob.
	Name          []string `protobuf:"bytes,1,rep,name=name,proto3" json:"name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListFilesResponse) Reset() {
	*x = ListFilesResponse{}
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListFilesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListFilesResponse) ProtoMessage() {}

func (x *ListFilesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListFilesResponse.ProtoReflect.Descriptor instead.
func (*ListFilesResponse) Descriptor() ([]byte, []int) {
	return file_clirpc_barter_backup_client_proto_rawDescGZIP(), []int{13}
}

func (x *ListFilesResponse) GetName() []string {
	if x != nil {
		return x.Name
	}
	return nil
}

// StorageConfig has settings that the user can change.
type StorageConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// allocated_storage_for_peers is the total number of bytes allocated to
	// store other peers' content.
	AllocatedStorageForPeers int64 `protobuf:"varint,1,opt,name=allocated_storage_for_peers,json=allocatedStorageForPeers,proto3" json:"allocated_storage_for_peers,omitempty"`
	// min_replicas is the minimum number of peers to store our content on.
	MinReplicas   int64 `protobuf:"varint,2,opt,name=min_replicas,json=minReplicas,proto3" json:"min_replicas,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StorageConfig) Reset() {
	*x = StorageConfig{}
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StorageConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StorageConfig) ProtoMessage() {}

func (x *StorageConfig) ProtoReflect() protoreflect.Message {
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StorageConfig.ProtoReflect.Descriptor instead.
func (*StorageConfig) Descriptor() ([]byte, []int) {
	return file_clirpc_barter_backup_client_proto_rawDescGZIP(), []int{14}
}

func (x *StorageConfig) GetAllocatedStorageForPeers() int64 {
	if x != nil {
		return x.AllocatedStorageForPeers
	}
	return 0
}

func (x *StorageConfig) GetMinReplicas() int64 {
	if x != nil {
		return x.MinReplicas
	}
	return 0
}

// StorageInfo is inferred data about storage configuration which the user
// can read, but can not change.
type StorageInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// online_peers_storage_obligations_bytes is total number of bytes we
	// spend on storing data of peers which are currently online and store
	// our most recent content properly.
	OnlinePeersStorageObligationsBytes int64 `protobuf:"varint,1,opt,name=online_peers_storage_obligations_bytes,json=onlinePeersStorageObligationsBytes,proto3" json:"online_peers_storage_obligations_bytes,omitempty"`
	// offline_peers_storage_obligations_bytes is total number of bytes we
	// spend on storing data of peers which are currently offline or who store
	// an outdated version of our content.
	OfflinePeersStorageObligationsBytes int64 `protobuf:"varint,2,opt,name=offline_peers_storage_obligations_bytes,json=offlinePeersStorageObligationsBytes,proto3" json:"offline_peers_storage_obligations_bytes,omitempty"`
	// expired_offline_peers_storage_obligations_bytes is a subset of
	// offline_peers_storage_obligations_bytes where the remote peer's
	// score is negative.
	ExpiredOfflinePeersStorageObligationsBytes int64 `protobuf:"varint,3,opt,name=expired_offline_peers_storage_obligations_bytes,json=expiredOfflinePeersStorageObligationsBytes,proto3" json:"expired_offline_peers_storage_obligations_bytes,omitempty"`
	// our_content_bytes is the number of bytes in our encrypted content.
	OurContentBytes int64 `protobuf:"varint,4,opt,name=our_content_bytes,json=ourContentBytes,proto3" json:"our_content_bytes,omitempty"`
	// maximum_peer_content_accepted_bytes is the maximum size of a remote
	// peer's content we can accept.
	MaximumPeerContentAcceptedBytes int64 `protobuf:"varint,5,opt,name=maximum_peer_content_accepted_bytes,json=maximumPeerContentAcceptedBytes,proto3" json:"maximum_peer_content_accepted_bytes,omitempty"`
	unknownFields                   protoimpl.UnknownFields
	sizeCache                       protoimpl.SizeCache
}

func (x *StorageInfo) Reset() {
	*x = StorageInfo{}
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StorageInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StorageInfo) ProtoMessage() {}

func (x *StorageInfo) ProtoReflect() protoreflect.Message {
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StorageInfo.ProtoReflect.Descriptor instead.
func (*StorageInfo) Descriptor() ([]byte, []int) {
	return file_clirpc_barter_backup_client_proto_rawDescGZIP(), []int{15}
}

func (x *StorageInfo) GetOnlinePeersStorageObligationsBytes() int64 {
	if x != nil {
		return x.OnlinePeersStorageObligationsBytes
	}
	return 0
}

func (x *StorageInfo) GetOfflinePeersStorageObligationsBytes() int64 {
	if x != nil {
		return x.OfflinePeersStorageObligationsBytes
	}
	return 0
}

func (x *StorageInfo) GetExpiredOfflinePeersStorageObligationsBytes() int64 {
	if x != nil {
		return x.ExpiredOfflinePeersStorageObligationsBytes
	}
	return 0
}

func (x *StorageInfo) GetOurContentBytes() int64 {
	if x != nil {
		return x.OurContentBytes
	}
	return 0
}

func (x *StorageInfo) GetMaximumPeerContentAcceptedBytes() int64 {
	if x != nil {
		return x.MaximumPeerContentAcceptedBytes
	}
	return 0
}

type SetStorageConfigRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// config is the new storage configuration to apply.
	Config        *StorageConfig `protobuf:"bytes,1,opt,name=config,proto3" json:"config,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SetStorageConfigRequest) Reset() {
	*x = SetStorageConfigRequest{}
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SetStorageConfigRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SetStorageConfigRequest) ProtoMessage() {}

func (x *SetStorageConfigRequest) ProtoReflect() protoreflect.Message {
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SetStorageConfigRequest.ProtoReflect.Descriptor instead.
func (*SetStorageConfigRequest) Descriptor() ([]byte, []int) {
	return file_clirpc_barter_backup_client_proto_rawDescGZIP(), []int{16}
}

func (x *SetStorageConfigRequest) GetConfig() *StorageConfig {
	if x != nil {
		return x.Config
	}
	return nil
}

type SetStorageConfigResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SetStorageConfigResponse) Reset() {
	*x = SetStorageConfigResponse{}
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SetStorageConfigResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SetStorageConfigResponse) ProtoMessage() {}

func (x *SetStorageConfigResponse) ProtoReflect() protoreflect.Message {
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SetStorageConfigResponse.ProtoReflect.Descriptor instead.
func (*SetStorageConfigResponse) Descriptor() ([]byte, []int) {
	return file_clirpc_barter_backup_client_proto_rawDescGZIP(), []int{17}
}

type GetStorageConfigRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetStorageConfigRequest) Reset() {
	*x = GetStorageConfigRequest{}
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetStorageConfigRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetStorageConfigRequest) ProtoMessage() {}

func (x *GetStorageConfigRequest) ProtoReflect() protoreflect.Message {
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetStorageConfigRequest.ProtoReflect.Descriptor instead.
func (*GetStorageConfigRequest) Descriptor() ([]byte, []int) {
	return file_clirpc_barter_backup_client_proto_rawDescGZIP(), []int{18}
}

type GetStorageConfigResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// config is the current storage configuration.
	Config *StorageConfig `protobuf:"bytes,1,opt,name=config,proto3" json:"config,omitempty"`
	// info reports derived storage information and capacity.
	Info          *StorageInfo `protobuf:"bytes,2,opt,name=info,proto3" json:"info,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetStorageConfigResponse) Reset() {
	*x = GetStorageConfigResponse{}
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetStorageConfigResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetStorageConfigResponse) ProtoMessage() {}

func (x *GetStorageConfigResponse) ProtoReflect() protoreflect.Message {
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetStorageConfigResponse.ProtoReflect.Descriptor instead.
func (*GetStorageConfigResponse) Descriptor() ([]byte, []int) {
	return file_clirpc_barter_backup_client_proto_rawDescGZIP(), []int{19}
}

func (x *GetStorageConfigResponse) GetConfig() *StorageConfig {
	if x != nil {
		return x.Config
	}
	return nil
}

func (x *GetStorageConfigResponse) GetInfo() *StorageInfo {
	if x != nil {
		return x.Info
	}
	return nil
}

type GetContractsRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetContractsRequest) Reset() {
	*x = GetContractsRequest{}
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetContractsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetContractsRequest) ProtoMessage() {}

func (x *GetContractsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetContractsRequest.ProtoReflect.Descriptor instead.
func (*GetContractsRequest) Descriptor() ([]byte, []int) {
	return file_clirpc_barter_backup_client_proto_rawDescGZIP(), []int{20}
}

// ContractInfo holds important information about a contract with a peer.
type ContractInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// peer specifies the peer with which there is this contract.
	Peer *Peer `protobuf:"bytes,1,opt,name=peer,proto3" json:"peer,omitempty"`
	// our_content_synced specifies if the peer stores the most recent version
	// of our content.
	OurContentSynced bool `protobuf:"varint,2,opt,name=our_content_synced,json=ourContentSynced,proto3" json:"our_content_synced,omitempty"`
	// our_remaining_seconds specifies our score from the peer's perspective.
	// The longer we have stored their content properly, the higher this number.
	OurRemainingSeconds int64 `protobuf:"varint,3,opt,name=our_remaining_seconds,json=ourRemainingSeconds,proto3" json:"our_remaining_seconds,omitempty"`
	// their_remaining_seconds specifies peer's score from our perspective.
	// The longer the peer stored our content properly, the higher this number.
	TheirRemainingSeconds int64 `protobuf:"varint,4,opt,name=their_remaining_seconds,json=theirRemainingSeconds,proto3" json:"their_remaining_seconds,omitempty"`
	// their_content_length is the number of bytes we spend on storing the
	// content of this peer.
	TheirContentLength int64 `protobuf:"varint,5,opt,name=their_content_length,json=theirContentLength,proto3" json:"their_content_length,omitempty"`
	// online indicates if the peer is online now.
	Online        bool `protobuf:"varint,6,opt,name=online,proto3" json:"online,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ContractInfo) Reset() {
	*x = ContractInfo{}
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ContractInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ContractInfo) ProtoMessage() {}

func (x *ContractInfo) ProtoReflect() protoreflect.Message {
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ContractInfo.ProtoReflect.Descriptor instead.
func (*ContractInfo) Descriptor() ([]byte, []int) {
	return file_clirpc_barter_backup_client_proto_rawDescGZIP(), []int{21}
}

func (x *ContractInfo) GetPeer() *Peer {
	if x != nil {
		return x.Peer
	}
	return nil
}

func (x *ContractInfo) GetOurContentSynced() bool {
	if x != nil {
		return x.OurContentSynced
	}
	return false
}

func (x *ContractInfo) GetOurRemainingSeconds() int64 {
	if x != nil {
		return x.OurRemainingSeconds
	}
	return 0
}

func (x *ContractInfo) GetTheirRemainingSeconds() int64 {
	if x != nil {
		return x.TheirRemainingSeconds
	}
	return 0
}

func (x *ContractInfo) GetTheirContentLength() int64 {
	if x != nil {
		return x.TheirContentLength
	}
	return 0
}

func (x *ContractInfo) GetOnline() bool {
	if x != nil {
		return x.Online
	}
	return false
}

type GetContractsResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Contracts     []*ContractInfo        `protobuf:"bytes,1,rep,name=contracts,proto3" json:"contracts,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetContractsResponse) Reset() {
	*x = GetContractsResponse{}
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetContractsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetContractsResponse) ProtoMessage() {}

func (x *GetContractsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetContractsResponse.ProtoReflect.Descriptor instead.
func (*GetContractsResponse) Descriptor() ([]byte, []int) {
	return file_clirpc_barter_backup_client_proto_rawDescGZIP(), []int{22}
}

func (x *GetContractsResponse) GetContracts() []*ContractInfo {
	if x != nil {
		return x.Contracts
	}
	return nil
}

// ProposeContractRequest asks the daemon to create or renew a contract with
// a specific peer.
type ProposeContractRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// peer is the peer to negotiate with.
	Peer          *Peer `protobuf:"bytes,1,opt,name=peer,proto3" json:"peer,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ProposeContractRequest) Reset() {
	*x = ProposeContractRequest{}
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProposeContractRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProposeContractRequest) ProtoMessage() {}

func (x *ProposeContractRequest) ProtoReflect() protoreflect.Message {
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ProposeContractRequest.ProtoReflect.Descriptor instead.
func (*ProposeContractRequest) Descriptor() ([]byte, []int) {
	return file_clirpc_barter_backup_client_proto_rawDescGZIP(), []int{23}
}

func (x *ProposeContractRequest) GetPeer() *Peer {
	if x != nil {
		return x.Peer
	}
	return nil
}

// ProposeContractUpdate reports progress or status changes while proposing a
// contract.
type ProposeContractUpdate struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// state is the current contract proposal state.
	State ContractState `protobuf:"varint,1,opt,name=state,proto3,enum=clirpc.ContractState" json:"state,omitempty"`
	// success is true when the proposal finished successfully.
	Success bool `protobuf:"varint,2,opt,name=success,proto3" json:"success,omitempty"`
	// their_content_length is the size of the peer's content in bytes.
	TheirContentLength int64 `protobuf:"varint,3,opt,name=their_content_length,json=theirContentLength,proto3" json:"their_content_length,omitempty"`
	// their_content_downloaded_bytes is the downloaded portion in bytes.
	TheirContentDownloadedBytes int64 `protobuf:"varint,4,opt,name=their_content_downloaded_bytes,json=theirContentDownloadedBytes,proto3" json:"their_content_downloaded_bytes,omitempty"`
	// our_content_length is our content size in bytes.
	OurContentLength int64 `protobuf:"varint,5,opt,name=our_content_length,json=ourContentLength,proto3" json:"our_content_length,omitempty"`
	// our_content_uploaded_bytes is the uploaded portion in bytes.
	OurContentUploadedBytes int64 `protobuf:"varint,6,opt,name=our_content_uploaded_bytes,json=ourContentUploadedBytes,proto3" json:"our_content_uploaded_bytes,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *ProposeContractUpdate) Reset() {
	*x = ProposeContractUpdate{}
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProposeContractUpdate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProposeContractUpdate) ProtoMessage() {}

func (x *ProposeContractUpdate) ProtoReflect() protoreflect.Message {
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ProposeContractUpdate.ProtoReflect.Descriptor instead.
func (*ProposeContractUpdate) Descriptor() ([]byte, []int) {
	return file_clirpc_barter_backup_client_proto_rawDescGZIP(), []int{24}
}

func (x *ProposeContractUpdate) GetState() ContractState {
	if x != nil {
		return x.State
	}
	return ContractState_NOT_STARTED
}

func (x *ProposeContractUpdate) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *ProposeContractUpdate) GetTheirContentLength() int64 {
	if x != nil {
		return x.TheirContentLength
	}
	return 0
}

func (x *ProposeContractUpdate) GetTheirContentDownloadedBytes() int64 {
	if x != nil {
		return x.TheirContentDownloadedBytes
	}
	return 0
}

func (x *ProposeContractUpdate) GetOurContentLength() int64 {
	if x != nil {
		return x.OurContentLength
	}
	return 0
}

func (x *ProposeContractUpdate) GetOurContentUploadedBytes() int64 {
	if x != nil {
		return x.OurContentUploadedBytes
	}
	return 0
}

// CheckContractRequest asks the daemon to verify a contract with a peer.
type CheckContractRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// peer is the peer to check.
	Peer          *Peer `protobuf:"bytes,1,opt,name=peer,proto3" json:"peer,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CheckContractRequest) Reset() {
	*x = CheckContractRequest{}
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CheckContractRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CheckContractRequest) ProtoMessage() {}

func (x *CheckContractRequest) ProtoReflect() protoreflect.Message {
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CheckContractRequest.ProtoReflect.Descriptor instead.
func (*CheckContractRequest) Descriptor() ([]byte, []int) {
	return file_clirpc_barter_backup_client_proto_rawDescGZIP(), []int{25}
}

func (x *CheckContractRequest) GetPeer() *Peer {
	if x != nil {
		return x.Peer
	}
	return nil
}

// CheckContractUpdate reports progress or status during a contract check.
type CheckContractUpdate struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// state is the current contract check state.
	State ContractState `protobuf:"varint,1,opt,name=state,proto3,enum=clirpc.ContractState" json:"state,omitempty"`
	// success is true when the check finished successfully.
	Success bool `protobuf:"varint,2,opt,name=success,proto3" json:"success,omitempty"`
	// our_content_length is our content size in bytes.
	OurContentLength int64 `protobuf:"varint,3,opt,name=our_content_length,json=ourContentLength,proto3" json:"our_content_length,omitempty"`
	// our_content_section_offset is the offset of the sampled section.
	OurContentSectionOffset int64 `protobuf:"varint,4,opt,name=our_content_section_offset,json=ourContentSectionOffset,proto3" json:"our_content_section_offset,omitempty"`
	// our_content_section_length is the length of the sampled section.
	OurContentSectionLength int64 `protobuf:"varint,5,opt,name=our_content_section_length,json=ourContentSectionLength,proto3" json:"our_content_section_length,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *CheckContractUpdate) Reset() {
	*x = CheckContractUpdate{}
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CheckContractUpdate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CheckContractUpdate) ProtoMessage() {}

func (x *CheckContractUpdate) ProtoReflect() protoreflect.Message {
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CheckContractUpdate.ProtoReflect.Descriptor instead.
func (*CheckContractUpdate) Descriptor() ([]byte, []int) {
	return file_clirpc_barter_backup_client_proto_rawDescGZIP(), []int{26}
}

func (x *CheckContractUpdate) GetState() ContractState {
	if x != nil {
		return x.State
	}
	return ContractState_NOT_STARTED
}

func (x *CheckContractUpdate) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *CheckContractUpdate) GetOurContentLength() int64 {
	if x != nil {
		return x.OurContentLength
	}
	return 0
}

func (x *CheckContractUpdate) GetOurContentSectionOffset() int64 {
	if x != nil {
		return x.OurContentSectionOffset
	}
	return 0
}

func (x *CheckContractUpdate) GetOurContentSectionLength() int64 {
	if x != nil {
		return x.OurContentSectionLength
	}
	return 0
}

// RecoverContentRequest triggers content recovery workflow.
type RecoverContentRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RecoverContentRequest) Reset() {
	*x = RecoverContentRequest{}
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RecoverContentRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RecoverContentRequest) ProtoMessage() {}

func (x *RecoverContentRequest) ProtoReflect() protoreflect.Message {
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RecoverContentRequest.ProtoReflect.Descriptor instead.
func (*RecoverContentRequest) Descriptor() ([]byte, []int) {
	return file_clirpc_barter_backup_client_proto_rawDescGZIP(), []int{27}
}

// RecoverContentUpdate reports recovery progress and events.
type RecoverContentUpdate struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// most_recent_content_id is the content_id of the most recent version.
	MostRecentContentId []byte `protobuf:"bytes,1,opt,name=most_recent_content_id,json=mostRecentContentId,proto3" json:"most_recent_content_id,omitempty"`
	// most_recent_ts is the Unix timestamp (seconds) of the most recent
	// revision.
	MostRecentTs int64 `protobuf:"varint,2,opt,name=most_recent_ts,json=mostRecentTs,proto3" json:"most_recent_ts,omitempty"`
	// most_recent_ts_ns is the nanosecond component corresponding to
	// most_recent_ts.
	MostRecentTsNs int64 `protobuf:"varint,3,opt,name=most_recent_ts_ns,json=mostRecentTsNs,proto3" json:"most_recent_ts_ns,omitempty"`
	// most_recent_length is the byte length of the most recent version.
	MostRecentLength int64 `protobuf:"varint,4,opt,name=most_recent_length,json=mostRecentLength,proto3" json:"most_recent_length,omitempty"`
	// num_peers_with_most_recent_version is the number of peers that have the
	// most recent version.
	NumPeersWithMostRecentVersion int64 `protobuf:"varint,5,opt,name=num_peers_with_most_recent_version,json=numPeersWithMostRecentVersion,proto3" json:"num_peers_with_most_recent_version,omitempty"`
	// total_versions_found is the total number of content versions discovered.
	TotalVersionsFound int64 `protobuf:"varint,6,opt,name=total_versions_found,json=totalVersionsFound,proto3" json:"total_versions_found,omitempty"`
	// num_peers_with_any_versions is the number of peers that have any
	// version of our content.
	NumPeersWithAnyVersions int64 `protobuf:"varint,7,opt,name=num_peers_with_any_versions,json=numPeersWithAnyVersions,proto3" json:"num_peers_with_any_versions,omitempty"`
	// most_recent_downloaded_bytes is the number of bytes downloaded for the
	// most recent version.
	MostRecentDownloadedBytes int64 `protobuf:"varint,8,opt,name=most_recent_downloaded_bytes,json=mostRecentDownloadedBytes,proto3" json:"most_recent_downloaded_bytes,omitempty"`
	// most_recent_downloaded_files is the number of files recovered for the
	// most recent version.
	MostRecentDownloadedFiles int64 `protobuf:"varint,9,opt,name=most_recent_downloaded_files,json=mostRecentDownloadedFiles,proto3" json:"most_recent_downloaded_files,omitempty"`
	// total_downloaded_bytes is the total number of bytes recovered.
	TotalDownloadedBytes int64 `protobuf:"varint,10,opt,name=total_downloaded_bytes,json=totalDownloadedBytes,proto3" json:"total_downloaded_bytes,omitempty"`
	// recovered_most_recent_version indicates whether the most recent version
	// has been fully recovered.
	RecoveredMostRecentVersion bool `protobuf:"varint,11,opt,name=recovered_most_recent_version,json=recoveredMostRecentVersion,proto3" json:"recovered_most_recent_version,omitempty"`
	unknownFields              protoimpl.UnknownFields
	sizeCache                  protoimpl.SizeCache
}

func (x *RecoverContentUpdate) Reset() {
	*x = RecoverContentUpdate{}
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RecoverContentUpdate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RecoverContentUpdate) ProtoMessage() {}

func (x *RecoverContentUpdate) ProtoReflect() protoreflect.Message {
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RecoverContentUpdate.ProtoReflect.Descriptor instead.
func (*RecoverContentUpdate) Descriptor() ([]byte, []int) {
	return file_clirpc_barter_backup_client_proto_rawDescGZIP(), []int{28}
}

func (x *RecoverContentUpdate) GetMostRecentContentId() []byte {
	if x != nil {
		return x.MostRecentContentId
	}
	return nil
}

func (x *RecoverContentUpdate) GetMostRecentTs() int64 {
	if x != nil {
		return x.MostRecentTs
	}
	return 0
}

func (x *RecoverContentUpdate) GetMostRecentTsNs() int64 {
	if x != nil {
		return x.MostRecentTsNs
	}
	return 0
}

func (x *RecoverContentUpdate) GetMostRecentLength() int64 {
	if x != nil {
		return x.MostRecentLength
	}
	return 0
}

func (x *RecoverContentUpdate) GetNumPeersWithMostRecentVersion() int64 {
	if x != nil {
		return x.NumPeersWithMostRecentVersion
	}
	return 0
}

func (x *RecoverContentUpdate) GetTotalVersionsFound() int64 {
	if x != nil {
		return x.TotalVersionsFound
	}
	return 0
}

func (x *RecoverContentUpdate) GetNumPeersWithAnyVersions() int64 {
	if x != nil {
		return x.NumPeersWithAnyVersions
	}
	return 0
}

func (x *RecoverContentUpdate) GetMostRecentDownloadedBytes() int64 {
	if x != nil {
		return x.MostRecentDownloadedBytes
	}
	return 0
}

func (x *RecoverContentUpdate) GetMostRecentDownloadedFiles() int64 {
	if x != nil {
		return x.MostRecentDownloadedFiles
	}
	return 0
}

func (x *RecoverContentUpdate) GetTotalDownloadedBytes() int64 {
	if x != nil {
		return x.TotalDownloadedBytes
	}
	return 0
}

func (x *RecoverContentUpdate) GetRecoveredMostRecentVersion() bool {
	if x != nil {
		return x.RecoveredMostRecentVersion
	}
	return false
}

// SetAeadKeyForPeerRequest configures a password-derived symmetric key for a
// peer chat.
type SetAeadKeyForPeerRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// peer is the peer for which to set the key.
	Peer *Peer `protobuf:"bytes,1,opt,name=peer,proto3" json:"peer,omitempty"`
	// password is the shared password to derive the AEAD key.
	Password      string `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SetAeadKeyForPeerRequest) Reset() {
	*x = SetAeadKeyForPeerRequest{}
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SetAeadKeyForPeerRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SetAeadKeyForPeerRequest) ProtoMessage() {}

func (x *SetAeadKeyForPeerRequest) ProtoReflect() protoreflect.Message {
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SetAeadKeyForPeerRequest.ProtoReflect.Descriptor instead.
func (*SetAeadKeyForPeerRequest) Descriptor() ([]byte, []int) {
	return file_clirpc_barter_backup_client_proto_rawDescGZIP(), []int{29}
}

func (x *SetAeadKeyForPeerRequest) GetPeer() *Peer {
	if x != nil {
		return x.Peer
	}
	return nil
}

func (x *SetAeadKeyForPeerRequest) GetPassword() string {
	if x != nil {
		return x.Password
	}
	return ""
}

// SetAeadKeyForPeerResponse is returned when the key is set.
type SetAeadKeyForPeerResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SetAeadKeyForPeerResponse) Reset() {
	*x = SetAeadKeyForPeerResponse{}
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SetAeadKeyForPeerResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SetAeadKeyForPeerResponse) ProtoMessage() {}

func (x *SetAeadKeyForPeerResponse) ProtoReflect() protoreflect.Message {
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SetAeadKeyForPeerResponse.ProtoReflect.Descriptor instead.
func (*SetAeadKeyForPeerResponse) Descriptor() ([]byte, []int) {
	return file_clirpc_barter_backup_client_proto_rawDescGZIP(), []int{30}
}

// ChatAction carries an action initiated by the CLI.
type ChatAction struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// chat_id uniquely identifies the chat session.
	ChatId int64 `protobuf:"varint,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	// peer is the chat counterpart onion service identifier.
	Peer *Peer `protobuf:"bytes,2,opt,name=peer,proto3" json:"peer,omitempty"`
	// Types that are valid to be assigned to Action:
	//
	//	*ChatAction_Init
	//	*ChatAction_SendMsg
	//	*ChatAction_SendFile
	//	*ChatAction_Stop
	Action        isChatAction_Action `protobuf_oneof:"action"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ChatAction) Reset() {
	*x = ChatAction{}
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[31]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChatAction) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChatAction) ProtoMessage() {}

func (x *ChatAction) ProtoReflect() protoreflect.Message {
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[31]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChatAction.ProtoReflect.Descriptor instead.
func (*ChatAction) Descriptor() ([]byte, []int) {
	return file_clirpc_barter_backup_client_proto_rawDescGZIP(), []int{31}
}

func (x *ChatAction) GetChatId() int64 {
	if x != nil {
		return x.ChatId
	}
	return 0
}

func (x *ChatAction) GetPeer() *Peer {
	if x != nil {
		return x.Peer
	}
	return nil
}

func (x *ChatAction) GetAction() isChatAction_Action {
	if x != nil {
		return x.Action
	}
	return nil
}

func (x *ChatAction) GetInit() *ChatInit {
	if x != nil {
		if x, ok := x.Action.(*ChatAction_Init); ok {
			return x.Init
		}
	}
	return nil
}

func (x *ChatAction) GetSendMsg() *ChatSendMsg {
	if x != nil {
		if x, ok := x.Action.(*ChatAction_SendMsg); ok {
			return x.SendMsg
		}
	}
	return nil
}

func (x *ChatAction) GetSendFile() *ChatSendFile {
	if x != nil {
		if x, ok := x.Action.(*ChatAction_SendFile); ok {
			return x.SendFile
		}
	}
	return nil
}

func (x *ChatAction) GetStop() *ChatStop {
	if x != nil {
		if x, ok := x.Action.(*ChatAction_Stop); ok {
			return x.Stop
		}
	}
	return nil
}

type isChatAction_Action interface {
	isChatAction_Action()
}

type ChatAction_Init struct {
	// init starts a chat session or joins a pending chat request.
	Init *ChatInit `protobuf:"bytes,3,opt,name=init,proto3,oneof"`
}

type ChatAction_SendMsg struct {
	// send_msg sends a text message.
	SendMsg *ChatSendMsg `protobuf:"bytes,4,opt,name=send_msg,json=sendMsg,proto3,oneof"`
}

type ChatAction_SendFile struct {
	// send_file offers a file to the peer.
	SendFile *ChatSendFile `protobuf:"bytes,5,opt,name=send_file,json=sendFile,proto3,oneof"`
}

type ChatAction_Stop struct {
	// stop ends the chat session.
	Stop *ChatStop `protobuf:"bytes,6,opt,name=stop,proto3,oneof"`
}

func (*ChatAction_Init) isChatAction_Action() {}

func (*ChatAction_SendMsg) isChatAction_Action() {}

func (*ChatAction_SendFile) isChatAction_Action() {}

func (*ChatAction_Stop) isChatAction_Action() {}

// ChatEvent carries an event produced by the daemon.
type ChatEvent struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// chat_id is the chat session identifier.
	ChatId int64 `protobuf:"varint,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	// Types that are valid to be assigned to Event:
	//
	//	*ChatEvent_Opened
	//	*ChatEvent_IncomingMsg
	//	*ChatEvent_FileOffered
	//	*ChatEvent_Closed
	//	*ChatEvent_Error
	Event         isChatEvent_Event `protobuf_oneof:"event"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ChatEvent) Reset() {
	*x = ChatEvent{}
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[32]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChatEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChatEvent) ProtoMessage() {}

func (x *ChatEvent) ProtoReflect() protoreflect.Message {
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[32]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChatEvent.ProtoReflect.Descriptor instead.
func (*ChatEvent) Descriptor() ([]byte, []int) {
	return file_clirpc_barter_backup_client_proto_rawDescGZIP(), []int{32}
}

func (x *ChatEvent) GetChatId() int64 {
	if x != nil {
		return x.ChatId
	}
	return 0
}

func (x *ChatEvent) GetEvent() isChatEvent_Event {
	if x != nil {
		return x.Event
	}
	return nil
}

func (x *ChatEvent) GetOpened() *ChatOpened {
	if x != nil {
		if x, ok := x.Event.(*ChatEvent_Opened); ok {
			return x.Opened
		}
	}
	return nil
}

func (x *ChatEvent) GetIncomingMsg() *ChatIncomingMsg {
	if x != nil {
		if x, ok := x.Event.(*ChatEvent_IncomingMsg); ok {
			return x.IncomingMsg
		}
	}
	return nil
}

func (x *ChatEvent) GetFileOffered() *ChatFileOffered {
	if x != nil {
		if x, ok := x.Event.(*ChatEvent_FileOffered); ok {
			return x.FileOffered
		}
	}
	return nil
}

func (x *ChatEvent) GetClosed() *ChatClosed {
	if x != nil {
		if x, ok := x.Event.(*ChatEvent_Closed); ok {
			return x.Closed
		}
	}
	return nil
}

func (x *ChatEvent) GetError() *ChatError {
	if x != nil {
		if x, ok := x.Event.(*ChatEvent_Error); ok {
			return x.Error
		}
	}
	return nil
}

type isChatEvent_Event interface {
	isChatEvent_Event()
}

type ChatEvent_Opened struct {
	// opened confirms that the chat session is open.
	Opened *ChatOpened `protobuf:"bytes,2,opt,name=opened,proto3,oneof"`
}

type ChatEvent_IncomingMsg struct {
	// incoming_msg is an incoming text message.
	IncomingMsg *ChatIncomingMsg `protobuf:"bytes,3,opt,name=incoming_msg,json=incomingMsg,proto3,oneof"`
}

type ChatEvent_FileOffered struct {
	// file_offered is a file the peer made available to download.
	FileOffered *ChatFileOffered `protobuf:"bytes,4,opt,name=file_offered,json=fileOffered,proto3,oneof"`
}

type ChatEvent_Closed struct {
	// closed indicates that the chat session has ended.
	Closed *ChatClosed `protobuf:"bytes,5,opt,name=closed,proto3,oneof"`
}

type ChatEvent_Error struct {
	// error is a human-readable error string.
	Error *ChatError `protobuf:"bytes,6,opt,name=error,proto3,oneof"`
}

func (*ChatEvent_Opened) isChatEvent_Event() {}

func (*ChatEvent_IncomingMsg) isChatEvent_Event() {}

func (*ChatEvent_FileOffered) isChatEvent_Event() {}

func (*ChatEvent_Closed) isChatEvent_Event() {}

func (*ChatEvent_Error) isChatEvent_Event() {}

// ChatInit starts a chat.
type ChatInit struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ChatInit) Reset() {
	*x = ChatInit{}
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[33]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChatInit) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChatInit) ProtoMessage() {}

func (x *ChatInit) ProtoReflect() protoreflect.Message {
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[33]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChatInit.ProtoReflect.Descriptor instead.
func (*ChatInit) Descriptor() ([]byte, []int) {
	return file_clirpc_barter_backup_client_proto_rawDescGZIP(), []int{33}
}

// ChatSendMsg contains an outgoing message body.
type ChatSendMsg struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// msg is the text message to send.
	Msg           string `protobuf:"bytes,1,opt,name=msg,proto3" json:"msg,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ChatSendMsg) Reset() {
	*x = ChatSendMsg{}
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[34]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChatSendMsg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChatSendMsg) ProtoMessage() {}

func (x *ChatSendMsg) ProtoReflect() protoreflect.Message {
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[34]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChatSendMsg.ProtoReflect.Descriptor instead.
func (*ChatSendMsg) Descriptor() ([]byte, []int) {
	return file_clirpc_barter_backup_client_proto_rawDescGZIP(), []int{34}
}

func (x *ChatSendMsg) GetMsg() string {
	if x != nil {
		return x.Msg
	}
	return ""
}

// ChatSendFile contains an outgoing file to offer via the chat.
type ChatSendFile struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name is a descriptive file name shown to the receiving user.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// local_file_path is local file path of the file to send. It is not
	// seen by the receiving user.
	LocalFilePath string `protobuf:"bytes,2,opt,name=local_file_path,json=localFilePath,proto3" json:"local_file_path,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ChatSendFile) Reset() {
	*x = ChatSendFile{}
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[35]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChatSendFile) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChatSendFile) ProtoMessage() {}

func (x *ChatSendFile) ProtoReflect() protoreflect.Message {
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[35]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChatSendFile.ProtoReflect.Descriptor instead.
func (*ChatSendFile) Descriptor() ([]byte, []int) {
	return file_clirpc_barter_backup_client_proto_rawDescGZIP(), []int{35}
}

func (x *ChatSendFile) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *ChatSendFile) GetLocalFilePath() string {
	if x != nil {
		return x.LocalFilePath
	}
	return ""
}

// ChatStop requests the chat to stop.
type ChatStop struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ChatStop) Reset() {
	*x = ChatStop{}
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[36]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChatStop) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChatStop) ProtoMessage() {}

func (x *ChatStop) ProtoReflect() protoreflect.Message {
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[36]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChatStop.ProtoReflect.Descriptor instead.
func (*ChatStop) Descriptor() ([]byte, []int) {
	return file_clirpc_barter_backup_client_proto_rawDescGZIP(), []int{36}
}

// ChatOpened acknowledges an opened chat.
type ChatOpened struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ChatOpened) Reset() {
	*x = ChatOpened{}
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[37]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChatOpened) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChatOpened) ProtoMessage() {}

func (x *ChatOpened) ProtoReflect() protoreflect.Message {
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[37]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChatOpened.ProtoReflect.Descriptor instead.
func (*ChatOpened) Descriptor() ([]byte, []int) {
	return file_clirpc_barter_backup_client_proto_rawDescGZIP(), []int{37}
}

// ChatIncomingMsg contains an incoming text message.
type ChatIncomingMsg struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// msg is a text message from the peer.
	Msg           string `protobuf:"bytes,1,opt,name=msg,proto3" json:"msg,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ChatIncomingMsg) Reset() {
	*x = ChatIncomingMsg{}
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[38]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChatIncomingMsg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChatIncomingMsg) ProtoMessage() {}

func (x *ChatIncomingMsg) ProtoReflect() protoreflect.Message {
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[38]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChatIncomingMsg.ProtoReflect.Descriptor instead.
func (*ChatIncomingMsg) Descriptor() ([]byte, []int) {
	return file_clirpc_barter_backup_client_proto_rawDescGZIP(), []int{38}
}

func (x *ChatIncomingMsg) GetMsg() string {
	if x != nil {
		return x.Msg
	}
	return ""
}

// ChatFileOffered describes a file available for download from the peer.
type ChatFileOffered struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name is a descriptive file name shown to the user.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// content_id is the identifier used for Download in bbrpc.
	ContentId []byte `protobuf:"bytes,2,opt,name=content_id,json=contentId,proto3" json:"content_id,omitempty"`
	// sha256 is the SHA-256 hash of the file.
	Sha256 []byte `protobuf:"bytes,3,opt,name=sha256,proto3" json:"sha256,omitempty"`
	// content_length is the total file size in bytes.
	ContentLength int64 `protobuf:"varint,4,opt,name=content_length,json=contentLength,proto3" json:"content_length,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ChatFileOffered) Reset() {
	*x = ChatFileOffered{}
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[39]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChatFileOffered) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChatFileOffered) ProtoMessage() {}

func (x *ChatFileOffered) ProtoReflect() protoreflect.Message {
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[39]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChatFileOffered.ProtoReflect.Descriptor instead.
func (*ChatFileOffered) Descriptor() ([]byte, []int) {
	return file_clirpc_barter_backup_client_proto_rawDescGZIP(), []int{39}
}

func (x *ChatFileOffered) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *ChatFileOffered) GetContentId() []byte {
	if x != nil {
		return x.ContentId
	}
	return nil
}

func (x *ChatFileOffered) GetSha256() []byte {
	if x != nil {
		return x.Sha256
	}
	return nil
}

func (x *ChatFileOffered) GetContentLength() int64 {
	if x != nil {
		return x.ContentLength
	}
	return 0
}

// ChatClosed signals the end of a chat.
type ChatClosed struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ChatClosed) Reset() {
	*x = ChatClosed{}
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[40]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChatClosed) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChatClosed) ProtoMessage() {}

func (x *ChatClosed) ProtoReflect() protoreflect.Message {
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[40]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChatClosed.ProtoReflect.Descriptor instead.
func (*ChatClosed) Descriptor() ([]byte, []int) {
	return file_clirpc_barter_backup_client_proto_rawDescGZIP(), []int{40}
}

// ChatError carries an error string related to the chat.
type ChatError struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// error is a human-readable error message.
	Error         string `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ChatError) Reset() {
	*x = ChatError{}
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[41]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChatError) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChatError) ProtoMessage() {}

func (x *ChatError) ProtoReflect() protoreflect.Message {
	mi := &file_clirpc_barter_backup_client_proto_msgTypes[41]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChatError.ProtoReflect.Descriptor instead.
func (*ChatError) Descriptor() ([]byte, []int) {
	return file_clirpc_barter_backup_client_proto_rawDescGZIP(), []int{41}
}

func (x *ChatError) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

var File_clirpc_barter_backup_client_proto protoreflect.FileDescriptor

const file_clirpc_barter_backup_client_proto_rawDesc = "" +
	"\n" +
	"!clirpc/barter_backup_client.proto\x12\x06clirpc\"4\n" +
	"\rUnlockRequest\x12#\n" +
	"\rmain_password\x18\x01 \x01(\tR\fmainPassword\"\x10\n" +
	"\x0eUnlockResponse\"0\n" +
	"\x04Peer\x12(\n" +
	"\x10onion_service_id\x18\x01 \x01(\tR\x0eonionServiceId\"6\n" +
	"\x12ConnectPeerRequest\x12 \n" +
	"\x04peer\x18\x01 \x01(\v2\f.clirpc.PeerR\x04peer\"\x15\n" +
	"\x13ConnectPeerResponse\"\x17\n" +
	"\x15ConnectedPeersRequest\"\xcd\x01\n" +
	"\x16ConnectedPeersResponse\x125\n" +
	"\x0fconnected_peers\x18\x01 \x03(\v2\f.clirpc.PeerR\x0econnectedPeers\x12I\n" +
	"\x1aonline_not_connected_peers\x18\x02 \x03(\v2\f.clirpc.PeerR\x17onlineNotConnectedPeers\x121\n" +
	"\roffline_peers\x18\x03 \x03(\v2\f.clirpc.PeerR\fofflinePeers\".\n" +
	"\x04File\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x12\n" +
	"\x04data\x18\x02 \x01(\fR\x04data\"2\n" +
	"\x0eSetFileRequest\x12 \n" +
	"\x04file\x18\x01 \x01(\v2\f.clirpc.FileR\x04file\"\x11\n" +
	"\x0fSetFileResponse\"$\n" +
	"\x0eGetFileRequest\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\"3\n" +
	"\x0fGetFileResponse\x12 \n" +
	"\x04file\x18\x01 \x01(\v2\f.clirpc.FileR\x04file\"\x12\n" +
	"\x10ListFilesRequest\"'\n" +
	"\x11ListFilesResponse\x12\x12\n" +
	"\x04name\x18\x01 \x03(\tR\x04name\"q\n" +
	"\rStorageConfig\x12=\n" +
	"\x1ballocated_storage_for_peers\x18\x01 \x01(\x03R\x18allocatedStorageForPeers\x12!\n" +
	"\fmin_replicas\x18\x02 \x01(\x03R\vminReplicas\"\x96\x03\n" +
	"\vStorageInfo\x12R\n" +
	"&online_peers_storage_obligations_bytes\x18\x01 \x01(\x03R\"onlinePeersStorageObligationsBytes\x12T\n" +
	"'offline_peers_storage_obligations_bytes\x18\x02 \x01(\x03R#offlinePeersStorageObligationsBytes\x12c\n" +
	"/expired_offline_peers_storage_obligations_bytes\x18\x03 \x01(\x03R*expiredOfflinePeersStorageObligationsBytes\x12*\n" +
	"\x11our_content_bytes\x18\x04 \x01(\x03R\x0fourContentBytes\x12L\n" +
	"#maximum_peer_content_accepted_bytes\x18\x05 \x01(\x03R\x1fmaximumPeerContentAcceptedBytes\"H\n" +
	"\x17SetStorageConfigRequest\x12-\n" +
	"\x06config\x18\x01 \x01(\v2\x15.clirpc.StorageConfigR\x06config\"\x1a\n" +
	"\x18SetStorageConfigResponse\"\x19\n" +
	"\x17GetStorageConfigRequest\"r\n" +
	"\x18GetStorageConfigResponse\x12-\n" +
	"\x06config\x18\x01 \x01(\v2\x15.clirpc.StorageConfigR\x06config\x12'\n" +
	"\x04info\x18\x02 \x01(\v2\x13.clirpc.StorageInfoR\x04info\"\x15\n" +
	"\x13GetContractsRequest\"\x94\x02\n" +
	"\fContractInfo\x12 \n" +
	"\x04peer\x18\x01 \x01(\v2\f.clirpc.PeerR\x04peer\x12,\n" +
	"\x12our_content_synced\x18\x02 \x01(\bR\x10ourContentSynced\x122\n" +
	"\x15our_remaining_seconds\x18\x03 \x01(\x03R\x13ourRemainingSeconds\x126\n" +
	"\x17their_remaining_seconds\x18\x04 \x01(\x03R\x15theirRemainingSeconds\x120\n" +
	"\x14their_content_length\x18\x05 \x01(\x03R\x12theirContentLength\x12\x16\n" +
	"\x06online\x18\x06 \x01(\bR\x06online\"J\n" +
	"\x14GetContractsResponse\x122\n" +
	"\tcontracts\x18\x01 \x03(\v2\x14.clirpc.ContractInfoR\tcontracts\":\n" +
	"\x16ProposeContractRequest\x12 \n" +
	"\x04peer\x18\x01 \x01(\v2\f.clirpc.PeerR\x04peer\"\xc0\x02\n" +
	"\x15ProposeContractUpdate\x12+\n" +
	"\x05state\x18\x01 \x01(\x0e2\x15.clirpc.ContractStateR\x05state\x12\x18\n" +
	"\asuccess\x18\x02 \x01(\bR\asuccess\x120\n" +
	"\x14their_content_length\x18\x03 \x01(\x03R\x12theirContentLength\x12C\n" +
	"\x1etheir_content_downloaded_bytes\x18\x04 \x01(\x03R\x1btheirContentDownloadedBytes\x12,\n" +
	"\x12our_content_length\x18\x05 \x01(\x03R\x10ourContentLength\x12;\n" +
	"\x1aour_content_uploaded_bytes\x18\x06 \x01(\x03R\x17ourContentUploadedBytes\"8\n" +
	"\x14CheckContractRequest\x12 \n" +
	"\x04peer\x18\x01 \x01(\v2\f.clirpc.PeerR\x04peer\"\x84\x02\n" +
	"\x13CheckContractUpdate\x12+\n" +
	"\x05state\x18\x01 \x01(\x0e2\x15.clirpc.ContractStateR\x05state\x12\x18\n" +
	"\asuccess\x18\x02 \x01(\bR\asuccess\x12,\n" +
	"\x12our_content_length\x18\x03 \x01(\x03R\x10ourContentLength\x12;\n" +
	"\x1aour_content_section_offset\x18\x04 \x01(\x03R\x17ourContentSectionOffset\x12;\n" +
	"\x1aour_content_section_length\x18\x05 \x01(\x03R\x17ourContentSectionLength\"\x17\n" +
	"\x15RecoverContentRequest\"\x80\x05\n" +
	"\x14RecoverContentUpdate\x123\n" +
	"\x16most_recent_content_id\x18\x01 \x01(\fR\x13mostRecentContentId\x12$\n" +
	"\x0emost_recent_ts\x18\x02 \x01(\x03R\fmostRecentTs\x12)\n" +
	"\x11most_recent_ts_ns\x18\x03 \x01(\x03R\x0emostRecentTsNs\x12,\n" +
	"\x12most_recent_length\x18\x04 \x01(\x03R\x10mostRecentLength\x12I\n" +
	"\"num_peers_with_most_recent_version\x18\x05 \x01(\x03R\x1dnumPeersWithMostRecentVersion\x120\n" +
	"\x14total_versions_found\x18\x06 \x01(\x03R\x12totalVersionsFound\x12<\n" +
	"\x1bnum_peers_with_any_versions\x18\a \x01(\x03R\x17numPeersWithAnyVersions\x12?\n" +
	"\x1cmost_recent_downloaded_bytes\x18\b \x01(\x03R\x19mostRecentDownloadedBytes\x12?\n" +
	"\x1cmost_recent_downloaded_files\x18\t \x01(\x03R\x19mostRecentDownloadedFiles\x124\n" +
	"\x16total_downloaded_bytes\x18\n" +
	" \x01(\x03R\x14totalDownloadedBytes\x12A\n" +
	"\x1drecovered_most_recent_version\x18\v \x01(\bR\x1arecoveredMostRecentVersion\"X\n" +
	"\x18SetAeadKeyForPeerRequest\x12 \n" +
	"\x04peer\x18\x01 \x01(\v2\f.clirpc.PeerR\x04peer\x12\x1a\n" +
	"\bpassword\x18\x02 \x01(\tR\bpassword\"\x1b\n" +
	"\x19SetAeadKeyForPeerResponse\"\x88\x02\n" +
	"\n" +
	"ChatAction\x12\x17\n" +
	"\achat_id\x18\x01 \x01(\x03R\x06chatId\x12 \n" +
	"\x04peer\x18\x02 \x01(\v2\f.clirpc.PeerR\x04peer\x12&\n" +
	"\x04init\x18\x03 \x01(\v2\x10.clirpc.ChatInitH\x00R\x04init\x120\n" +
	"\bsend_msg\x18\x04 \x01(\v2\x13.clirpc.ChatSendMsgH\x00R\asendMsg\x123\n" +
	"\tsend_file\x18\x05 \x01(\v2\x14.clirpc.ChatSendFileH\x00R\bsendFile\x12&\n" +
	"\x04stop\x18\x06 \x01(\v2\x10.clirpc.ChatStopH\x00R\x04stopB\b\n" +
	"\x06action\"\xb0\x02\n" +
	"\tChatEvent\x12\x17\n" +
	"\achat_id\x18\x01 \x01(\x03R\x06chatId\x12,\n" +
	"\x06opened\x18\x02 \x01(\v2\x12.clirpc.ChatOpenedH\x00R\x06opened\x12<\n" +
	"\fincoming_msg\x18\x03 \x01(\v2\x17.clirpc.ChatIncomingMsgH\x00R\vincomingMsg\x12<\n" +
	"\ffile_offered\x18\x04 \x01(\v2\x17.clirpc.ChatFileOfferedH\x00R\vfileOffered\x12,\n" +
	"\x06closed\x18\x05 \x01(\v2\x12.clirpc.ChatClosedH\x00R\x06closed\x12)\n" +
	"\x05error\x18\x06 \x01(\v2\x11.clirpc.ChatErrorH\x00R\x05errorB\a\n" +
	"\x05event\"\n" +
	"\n" +
	"\bChatInit\"\x1f\n" +
	"\vChatSendMsg\x12\x10\n" +
	"\x03msg\x18\x01 \x01(\tR\x03msg\"J\n" +
	"\fChatSendFile\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12&\n" +
	"\x0flocal_file_path\x18\x02 \x01(\tR\rlocalFilePath\"\n" +
	"\n" +
	"\bChatStop\"\f\n" +
	"\n" +
	"ChatOpened\"#\n" +
	"\x0fChatIncomingMsg\x12\x10\n" +
	"\x03msg\x18\x01 \x01(\tR\x03msg\"\x83\x01\n" +
	"\x0fChatFileOffered\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x1d\n" +
	"\n" +
	"content_id\x18\x02 \x01(\fR\tcontentId\x12\x16\n" +
	"\x06sha256\x18\x03 \x01(\fR\x06sha256\x12%\n" +
	"\x0econtent_length\x18\x04 \x01(\x03R\rcontentLength\"\f\n" +
	"\n" +
	"ChatClosed\"!\n" +
	"\tChatError\x12\x14\n" +
	"\x05error\x18\x01 \x01(\tR\x05error*\xde\x01\n" +
	"\rContractState\x12\x0f\n" +
	"\vNOT_STARTED\x10\x00\x12\x16\n" +
	"\x12CONNECTING_TO_PEER\x10\x01\x12\x16\n" +
	"\x12PROPOSING_CONTRACT\x10\x02\x12\x10\n" +
	"\fPEER_REFUSED\x10\x03\x12\x14\n" +
	"\x10SYNCING_CONTENTS\x10\x04\x12\x15\n" +
	"\x11CHECKING_CONTENTS\x10\x05\x12 \n" +
	"\x1cOUR_CONTENT_REVISION_MISSING\x10\x06\x12\x1c\n" +
	"\x18INVALID_CONTENT_RETURNED\x10\a\x12\r\n" +
	"\tCOMPLETED\x10\b2\x99\b\n" +
	"\x12BarterBackupClient\x127\n" +
	"\x06Unlock\x12\x15.clirpc.UnlockRequest\x1a\x16.clirpc.UnlockResponse\x12F\n" +
	"\vConnectPeer\x12\x1a.clirpc.ConnectPeerRequest\x1a\x1b.clirpc.ConnectPeerResponse\x12O\n" +
	"\x0eConnectedPeers\x12\x1d.clirpc.ConnectedPeersRequest\x1a\x1e.clirpc.ConnectedPeersResponse\x12:\n" +
	"\aSetFile\x12\x16.clirpc.SetFileRequest\x1a\x17.clirpc.SetFileResponse\x12:\n" +
	"\aGetFile\x12\x16.clirpc.GetFileRequest\x1a\x17.clirpc.GetFileResponse\x12@\n" +
	"\tListFiles\x12\x18.clirpc.ListFilesRequest\x1a\x19.clirpc.ListFilesResponse\x12U\n" +
	"\x10SetStorageConfig\x12\x1f.clirpc.SetStorageConfigRequest\x1a .clirpc.SetStorageConfigResponse\x12U\n" +
	"\x10GetStorageConfig\x12\x1f.clirpc.GetStorageConfigRequest\x1a .clirpc.GetStorageConfigResponse\x12I\n" +
	"\fGetContracts\x12\x1b.clirpc.GetContractsRequest\x1a\x1c.clirpc.GetContractsResponse\x12R\n" +
	"\x0fProposeContract\x12\x1e.clirpc.ProposeContractRequest\x1a\x1d.clirpc.ProposeContractUpdate0\x01\x12L\n" +
	"\rCheckContract\x12\x1c.clirpc.CheckContractRequest\x1a\x1b.clirpc.CheckContractUpdate0\x01\x12O\n" +
	"\x0eRecoverContent\x12\x1d.clirpc.RecoverContentRequest\x1a\x1c.clirpc.RecoverContentUpdate0\x01\x12X\n" +
	"\x11SetAeadKeyForPeer\x12 .clirpc.SetAeadKeyForPeerRequest\x1a!.clirpc.SetAeadKeyForPeerResponse\x121\n" +
	"\x04Chat\x12\x12.clirpc.ChatAction\x1a\x11.clirpc.ChatEvent(\x010\x01B(Z&github.com/starius/barterbackup/clirpcb\x06proto3"

var (
	file_clirpc_barter_backup_client_proto_rawDescOnce sync.Once
	file_clirpc_barter_backup_client_proto_rawDescData []byte
)

func file_clirpc_barter_backup_client_proto_rawDescGZIP() []byte {
	file_clirpc_barter_backup_client_proto_rawDescOnce.Do(func() {
		file_clirpc_barter_backup_client_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_clirpc_barter_backup_client_proto_rawDesc), len(file_clirpc_barter_backup_client_proto_rawDesc)))
	})
	return file_clirpc_barter_backup_client_proto_rawDescData
}

var file_clirpc_barter_backup_client_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_clirpc_barter_backup_client_proto_msgTypes = make([]protoimpl.MessageInfo, 42)
var file_clirpc_barter_backup_client_proto_goTypes = []any{
	(ContractState)(0),                // 0: clirpc.ContractState
	(*UnlockRequest)(nil),             // 1: clirpc.UnlockRequest
	(*UnlockResponse)(nil),            // 2: clirpc.UnlockResponse
	(*Peer)(nil),                      // 3: clirpc.Peer
	(*ConnectPeerRequest)(nil),        // 4: clirpc.ConnectPeerRequest
	(*ConnectPeerResponse)(nil),       // 5: clirpc.ConnectPeerResponse
	(*ConnectedPeersRequest)(nil),     // 6: clirpc.ConnectedPeersRequest
	(*ConnectedPeersResponse)(nil),    // 7: clirpc.ConnectedPeersResponse
	(*File)(nil),                      // 8: clirpc.File
	(*SetFileRequest)(nil),            // 9: clirpc.SetFileRequest
	(*SetFileResponse)(nil),           // 10: clirpc.SetFileResponse
	(*GetFileRequest)(nil),            // 11: clirpc.GetFileRequest
	(*GetFileResponse)(nil),           // 12: clirpc.GetFileResponse
	(*ListFilesRequest)(nil),          // 13: clirpc.ListFilesRequest
	(*ListFilesResponse)(nil),         // 14: clirpc.ListFilesResponse
	(*StorageConfig)(nil),             // 15: clirpc.StorageConfig
	(*StorageInfo)(nil),               // 16: clirpc.StorageInfo
	(*SetStorageConfigRequest)(nil),   // 17: clirpc.SetStorageConfigRequest
	(*SetStorageConfigResponse)(nil),  // 18: clirpc.SetStorageConfigResponse
	(*GetStorageConfigRequest)(nil),   // 19: clirpc.GetStorageConfigRequest
	(*GetStorageConfigResponse)(nil),  // 20: clirpc.GetStorageConfigResponse
	(*GetContractsRequest)(nil),       // 21: clirpc.GetContractsRequest
	(*ContractInfo)(nil),              // 22: clirpc.ContractInfo
	(*GetContractsResponse)(nil),      // 23: clirpc.GetContractsResponse
	(*ProposeContractRequest)(nil),    // 24: clirpc.ProposeContractRequest
	(*ProposeContractUpdate)(nil),     // 25: clirpc.ProposeContractUpdate
	(*CheckContractRequest)(nil),      // 26: clirpc.CheckContractRequest
	(*CheckContractUpdate)(nil),       // 27: clirpc.CheckContractUpdate
	(*RecoverContentRequest)(nil),     // 28: clirpc.RecoverContentRequest
	(*RecoverContentUpdate)(nil),      // 29: clirpc.RecoverContentUpdate
	(*SetAeadKeyForPeerRequest)(nil),  // 30: clirpc.SetAeadKeyForPeerRequest
	(*SetAeadKeyForPeerResponse)(nil), // 31: clirpc.SetAeadKeyForPeerResponse
	(*ChatAction)(nil),                // 32: clirpc.ChatAction
	(*ChatEvent)(nil),                 // 33: clirpc.ChatEvent
	(*ChatInit)(nil),                  // 34: clirpc.ChatInit
	(*ChatSendMsg)(nil),               // 35: clirpc.ChatSendMsg
	(*ChatSendFile)(nil),              // 36: clirpc.ChatSendFile
	(*ChatStop)(nil),                  // 37: clirpc.ChatStop
	(*ChatOpened)(nil),                // 38: clirpc.ChatOpened
	(*ChatIncomingMsg)(nil),           // 39: clirpc.ChatIncomingMsg
	(*ChatFileOffered)(nil),           // 40: clirpc.ChatFileOffered
	(*ChatClosed)(nil),                // 41: clirpc.ChatClosed
	(*ChatError)(nil),                 // 42: clirpc.ChatError
}
var file_clirpc_barter_backup_client_proto_depIdxs = []int32{
	3,  // 0: clirpc.ConnectPeerRequest.peer:type_name -> clirpc.Peer
	3,  // 1: clirpc.ConnectedPeersResponse.connected_peers:type_name -> clirpc.Peer
	3,  // 2: clirpc.ConnectedPeersResponse.online_not_connected_peers:type_name -> clirpc.Peer
	3,  // 3: clirpc.ConnectedPeersResponse.offline_peers:type_name -> clirpc.Peer
	8,  // 4: clirpc.SetFileRequest.file:type_name -> clirpc.File
	8,  // 5: clirpc.GetFileResponse.file:type_name -> clirpc.File
	15, // 6: clirpc.SetStorageConfigRequest.config:type_name -> clirpc.StorageConfig
	15, // 7: clirpc.GetStorageConfigResponse.config:type_name -> clirpc.StorageConfig
	16, // 8: clirpc.GetStorageConfigResponse.info:type_name -> clirpc.StorageInfo
	3,  // 9: clirpc.ContractInfo.peer:type_name -> clirpc.Peer
	22, // 10: clirpc.GetContractsResponse.contracts:type_name -> clirpc.ContractInfo
	3,  // 11: clirpc.ProposeContractRequest.peer:type_name -> clirpc.Peer
	0,  // 12: clirpc.ProposeContractUpdate.state:type_name -> clirpc.ContractState
	3,  // 13: clirpc.CheckContractRequest.peer:type_name -> clirpc.Peer
	0,  // 14: clirpc.CheckContractUpdate.state:type_name -> clirpc.ContractState
	3,  // 15: clirpc.SetAeadKeyForPeerRequest.peer:type_name -> clirpc.Peer
	3,  // 16: clirpc.ChatAction.peer:type_name -> clirpc.Peer
	34, // 17: clirpc.ChatAction.init:type_name -> clirpc.ChatInit
	35, // 18: clirpc.ChatAction.send_msg:type_name -> clirpc.ChatSendMsg
	36, // 19: clirpc.ChatAction.send_file:type_name -> clirpc.ChatSendFile
	37, // 20: clirpc.ChatAction.stop:type_name -> clirpc.ChatStop
	38, // 21: clirpc.ChatEvent.opened:type_name -> clirpc.ChatOpened
	39, // 22: clirpc.ChatEvent.incoming_msg:type_name -> clirpc.ChatIncomingMsg
	40, // 23: clirpc.ChatEvent.file_offered:type_name -> clirpc.ChatFileOffered
	41, // 24: clirpc.ChatEvent.closed:type_name -> clirpc.ChatClosed
	42, // 25: clirpc.ChatEvent.error:type_name -> clirpc.ChatError
	1,  // 26: clirpc.BarterBackupClient.Unlock:input_type -> clirpc.UnlockRequest
	4,  // 27: clirpc.BarterBackupClient.ConnectPeer:input_type -> clirpc.ConnectPeerRequest
	6,  // 28: clirpc.BarterBackupClient.ConnectedPeers:input_type -> clirpc.ConnectedPeersRequest
	9,  // 29: clirpc.BarterBackupClient.SetFile:input_type -> clirpc.SetFileRequest
	11, // 30: clirpc.BarterBackupClient.GetFile:input_type -> clirpc.GetFileRequest
	13, // 31: clirpc.BarterBackupClient.ListFiles:input_type -> clirpc.ListFilesRequest
	17, // 32: clirpc.BarterBackupClient.SetStorageConfig:input_type -> clirpc.SetStorageConfigRequest
	19, // 33: clirpc.BarterBackupClient.GetStorageConfig:input_type -> clirpc.GetStorageConfigRequest
	21, // 34: clirpc.BarterBackupClient.GetContracts:input_type -> clirpc.GetContractsRequest
	24, // 35: clirpc.BarterBackupClient.ProposeContract:input_type -> clirpc.ProposeContractRequest
	26, // 36: clirpc.BarterBackupClient.CheckContract:input_type -> clirpc.CheckContractRequest
	28, // 37: clirpc.BarterBackupClient.RecoverContent:input_type -> clirpc.RecoverContentRequest
	30, // 38: clirpc.BarterBackupClient.SetAeadKeyForPeer:input_type -> clirpc.SetAeadKeyForPeerRequest
	32, // 39: clirpc.BarterBackupClient.Chat:input_type -> clirpc.ChatAction
	2,  // 40: clirpc.BarterBackupClient.Unlock:output_type -> clirpc.UnlockResponse
	5,  // 41: clirpc.BarterBackupClient.ConnectPeer:output_type -> clirpc.ConnectPeerResponse
	7,  // 42: clirpc.BarterBackupClient.ConnectedPeers:output_type -> clirpc.ConnectedPeersResponse
	10, // 43: clirpc.BarterBackupClient.SetFile:output_type -> clirpc.SetFileResponse
	12, // 44: clirpc.BarterBackupClient.GetFile:output_type -> clirpc.GetFileResponse
	14, // 45: clirpc.BarterBackupClient.ListFiles:output_type -> clirpc.ListFilesResponse
	18, // 46: clirpc.BarterBackupClient.SetStorageConfig:output_type -> clirpc.SetStorageConfigResponse
	20, // 47: clirpc.BarterBackupClient.GetStorageConfig:output_type -> clirpc.GetStorageConfigResponse
	23, // 48: clirpc.BarterBackupClient.GetContracts:output_type -> clirpc.GetContractsResponse
	25, // 49: clirpc.BarterBackupClient.ProposeContract:output_type -> clirpc.ProposeContractUpdate
	27, // 50: clirpc.BarterBackupClient.CheckContract:output_type -> clirpc.CheckContractUpdate
	29, // 51: clirpc.BarterBackupClient.RecoverContent:output_type -> clirpc.RecoverContentUpdate
	31, // 52: clirpc.BarterBackupClient.SetAeadKeyForPeer:output_type -> clirpc.SetAeadKeyForPeerResponse
	33, // 53: clirpc.BarterBackupClient.Chat:output_type -> clirpc.ChatEvent
	40, // [40:54] is the sub-list for method output_type
	26, // [26:40] is the sub-list for method input_type
	26, // [26:26] is the sub-list for extension type_name
	26, // [26:26] is the sub-list for extension extendee
	0,  // [0:26] is the sub-list for field type_name
}

func init() { file_clirpc_barter_backup_client_proto_init() }
func file_clirpc_barter_backup_client_proto_init() {
	if File_clirpc_barter_backup_client_proto != nil {
		return
	}
	file_clirpc_barter_backup_client_proto_msgTypes[31].OneofWrappers = []any{
		(*ChatAction_Init)(nil),
		(*ChatAction_SendMsg)(nil),
		(*ChatAction_SendFile)(nil),
		(*ChatAction_Stop)(nil),
	}
	file_clirpc_barter_backup_client_proto_msgTypes[32].OneofWrappers = []any{
		(*ChatEvent_Opened)(nil),
		(*ChatEvent_IncomingMsg)(nil),
		(*ChatEvent_FileOffered)(nil),
		(*ChatEvent_Closed)(nil),
		(*ChatEvent_Error)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_clirpc_barter_backup_client_proto_rawDesc), len(file_clirpc_barter_backup_client_proto_rawDesc)),
			NumEnums:      1,
			NumMessages:   42,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_clirpc_barter_backup_client_proto_goTypes,
		DependencyIndexes: file_clirpc_barter_backup_client_proto_depIdxs,
		EnumInfos:         file_clirpc_barter_backup_client_proto_enumTypes,
		MessageInfos:      file_clirpc_barter_backup_client_proto_msgTypes,
	}.Build()
	File_clirpc_barter_backup_client_proto = out.File
	file_clirpc_barter_backup_client_proto_goTypes = nil
	file_clirpc_barter_backup_client_proto_depIdxs = nil
}
