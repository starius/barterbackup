// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.21.12
// source: clirpc/barter_backup_client.proto

package clirpc

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	BarterBackupClient_LocalHealthCheck_FullMethodName  = "/clirpc.BarterBackupClient/LocalHealthCheck"
	BarterBackupClient_Unlock_FullMethodName            = "/clirpc.BarterBackupClient/Unlock"
	BarterBackupClient_ConnectPeer_FullMethodName       = "/clirpc.BarterBackupClient/ConnectPeer"
	BarterBackupClient_ConnectedPeers_FullMethodName    = "/clirpc.BarterBackupClient/ConnectedPeers"
	BarterBackupClient_SetFile_FullMethodName           = "/clirpc.BarterBackupClient/SetFile"
	BarterBackupClient_GetFile_FullMethodName           = "/clirpc.BarterBackupClient/GetFile"
	BarterBackupClient_ListFiles_FullMethodName         = "/clirpc.BarterBackupClient/ListFiles"
	BarterBackupClient_SetStorageConfig_FullMethodName  = "/clirpc.BarterBackupClient/SetStorageConfig"
	BarterBackupClient_GetStorageConfig_FullMethodName  = "/clirpc.BarterBackupClient/GetStorageConfig"
	BarterBackupClient_GetContracts_FullMethodName      = "/clirpc.BarterBackupClient/GetContracts"
	BarterBackupClient_ProposeContract_FullMethodName   = "/clirpc.BarterBackupClient/ProposeContract"
	BarterBackupClient_CheckContract_FullMethodName     = "/clirpc.BarterBackupClient/CheckContract"
	BarterBackupClient_RecoverContent_FullMethodName    = "/clirpc.BarterBackupClient/RecoverContent"
	BarterBackupClient_SetAeadKeyForPeer_FullMethodName = "/clirpc.BarterBackupClient/SetAeadKeyForPeer"
	BarterBackupClient_CliChat_FullMethodName           = "/clirpc.BarterBackupClient/CliChat"
)

// BarterBackupClientClient is the client API for BarterBackupClient service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// BarterBackupClient is a gRPC service implemented by the BarterBackup
// daemon and exposed locally. The CLI tool speaks to the daemon using this
// protocol.
//
// Terminology:
//   - File: A user-provided file (one or more) that a client uploads to the
//     daemon. Files are inputs.
//   - Content: A single finalized encrypted blob produced by the daemon from
//     the current set of files. This is what gets backed up to peers.
type BarterBackupClientClient interface {
	// LocalHealthCheck returns success when the local daemon is healthy.
	// Renamed from HealthCheck to avoid a method name collision with bbrpc
	// on the shared Node implementation.
	LocalHealthCheck(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error)
	// Unlock sends the main password to the daemon. The password is used to
	// derive the master secret key from which all other keys are derived,
	// for encryption, onion service private key, and for authentication.
	Unlock(ctx context.Context, in *UnlockRequest, opts ...grpc.CallOption) (*UnlockResponse, error)
	// ConnectPeer adds the peer to the list of known peers. The daemon will
	// try to connect to it.
	ConnectPeer(ctx context.Context, in *ConnectPeerRequest, opts ...grpc.CallOption) (*ConnectPeerResponse, error)
	// ConnectedPeers returns the list of connected online peers.
	ConnectedPeers(ctx context.Context, in *ConnectedPeersRequest, opts ...grpc.CallOption) (*ConnectedPeersResponse, error)
	// SetFile sends a single file to the daemon. The daemon assembles a
	// single content blob from the current set of files, stores it encrypted
	// locally, and uploads the resulting content to other peers (also
	// encrypted). It stores other peers' content in exchange.
	SetFile(ctx context.Context, in *SetFileRequest, opts ...grpc.CallOption) (*SetFileResponse, error)
	// GetFile returns the file data by its name from the current set of
	// files that form the most recent content blob.
	GetFile(ctx context.Context, in *GetFileRequest, opts ...grpc.CallOption) (*GetFileResponse, error)
	// ListFiles returns only the names of files that form the most recent
	// content blob.
	ListFiles(ctx context.Context, in *ListFilesRequest, opts ...grpc.CallOption) (*ListFilesResponse, error)
	// SetStorageConfig sets how much data of other peers we want to store
	// and what is the minimum number of replicas (peers) we want to store
	// data on. We also have obligations under old contracts (where peers are
	// offline but still have remaining time to download their data from us).
	// Given all of this it is possible to reduce the maximum content length
	// of another peer we accept into our storage.
	SetStorageConfig(ctx context.Context, in *SetStorageConfigRequest, opts ...grpc.CallOption) (*SetStorageConfigResponse, error)
	// GetStorageConfig returns the current storage configuration.
	GetStorageConfig(ctx context.Context, in *GetStorageConfigRequest, opts ...grpc.CallOption) (*GetStorageConfigResponse, error)
	// GetContracts returns the current state of storage contracts.
	GetContracts(ctx context.Context, in *GetContractsRequest, opts ...grpc.CallOption) (*GetContractsResponse, error)
	// ProposeContract tells the server to form a contract if not already
	// present with the specified peer.
	ProposeContract(ctx context.Context, in *ProposeContractRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ProposeContractUpdate], error)
	// CheckContract tells the server to check the contract with the peer.
	// It verifies that we and the peer store the most recent versions of
	// contents of each other, then downloads a random piece of our content
	// from the peer and verifies it. Such checks are also run in the
	// background.
	CheckContract(ctx context.Context, in *CheckContractRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[CheckContractUpdate], error)
	// RecoverContent triggers content recovery from peers. The daemon does
	// it on its own after starting and in the background. This just triggers
	// it. The stream works forever sending new recovery events.
	RecoverContent(ctx context.Context, in *RecoverContentRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[RecoverContentUpdate], error)
	// SetAeadKeyForPeer sets a password for symmetric encryption of chats
	// with the peer. This is an additional measure to secure communications.
	// The password has to be shared between the peers out-of-band. The key
	// derived from the password is encrypted and added to the stored content
	// so it will survive a node reset together with the main content.
	SetAeadKeyForPeer(ctx context.Context, in *SetAeadKeyForPeerRequest, opts ...grpc.CallOption) (*SetAeadKeyForPeerResponse, error)
	// CliChat initiates a chat with a node. When the stream is closed, the
	// chat is ended. It uses a symmetrically encrypted chat if the AEAD key
	// is set for the node. File transfers over the chat are passed through
	// the stream.
	// Renamed from Chat to avoid a method name collision with bbrpc on the
	// shared Node implementation.
	CliChat(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[ChatAction, ChatEvent], error)
}

type barterBackupClientClient struct {
	cc grpc.ClientConnInterface
}

func NewBarterBackupClientClient(cc grpc.ClientConnInterface) BarterBackupClientClient {
	return &barterBackupClientClient{cc}
}

func (c *barterBackupClientClient) LocalHealthCheck(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HealthCheckResponse)
	err := c.cc.Invoke(ctx, BarterBackupClient_LocalHealthCheck_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *barterBackupClientClient) Unlock(ctx context.Context, in *UnlockRequest, opts ...grpc.CallOption) (*UnlockResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UnlockResponse)
	err := c.cc.Invoke(ctx, BarterBackupClient_Unlock_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *barterBackupClientClient) ConnectPeer(ctx context.Context, in *ConnectPeerRequest, opts ...grpc.CallOption) (*ConnectPeerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConnectPeerResponse)
	err := c.cc.Invoke(ctx, BarterBackupClient_ConnectPeer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *barterBackupClientClient) ConnectedPeers(ctx context.Context, in *ConnectedPeersRequest, opts ...grpc.CallOption) (*ConnectedPeersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConnectedPeersResponse)
	err := c.cc.Invoke(ctx, BarterBackupClient_ConnectedPeers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *barterBackupClientClient) SetFile(ctx context.Context, in *SetFileRequest, opts ...grpc.CallOption) (*SetFileResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetFileResponse)
	err := c.cc.Invoke(ctx, BarterBackupClient_SetFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *barterBackupClientClient) GetFile(ctx context.Context, in *GetFileRequest, opts ...grpc.CallOption) (*GetFileResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetFileResponse)
	err := c.cc.Invoke(ctx, BarterBackupClient_GetFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *barterBackupClientClient) ListFiles(ctx context.Context, in *ListFilesRequest, opts ...grpc.CallOption) (*ListFilesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListFilesResponse)
	err := c.cc.Invoke(ctx, BarterBackupClient_ListFiles_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *barterBackupClientClient) SetStorageConfig(ctx context.Context, in *SetStorageConfigRequest, opts ...grpc.CallOption) (*SetStorageConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetStorageConfigResponse)
	err := c.cc.Invoke(ctx, BarterBackupClient_SetStorageConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *barterBackupClientClient) GetStorageConfig(ctx context.Context, in *GetStorageConfigRequest, opts ...grpc.CallOption) (*GetStorageConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetStorageConfigResponse)
	err := c.cc.Invoke(ctx, BarterBackupClient_GetStorageConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *barterBackupClientClient) GetContracts(ctx context.Context, in *GetContractsRequest, opts ...grpc.CallOption) (*GetContractsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetContractsResponse)
	err := c.cc.Invoke(ctx, BarterBackupClient_GetContracts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *barterBackupClientClient) ProposeContract(ctx context.Context, in *ProposeContractRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ProposeContractUpdate], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &BarterBackupClient_ServiceDesc.Streams[0], BarterBackupClient_ProposeContract_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ProposeContractRequest, ProposeContractUpdate]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type BarterBackupClient_ProposeContractClient = grpc.ServerStreamingClient[ProposeContractUpdate]

func (c *barterBackupClientClient) CheckContract(ctx context.Context, in *CheckContractRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[CheckContractUpdate], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &BarterBackupClient_ServiceDesc.Streams[1], BarterBackupClient_CheckContract_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[CheckContractRequest, CheckContractUpdate]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type BarterBackupClient_CheckContractClient = grpc.ServerStreamingClient[CheckContractUpdate]

func (c *barterBackupClientClient) RecoverContent(ctx context.Context, in *RecoverContentRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[RecoverContentUpdate], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &BarterBackupClient_ServiceDesc.Streams[2], BarterBackupClient_RecoverContent_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[RecoverContentRequest, RecoverContentUpdate]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type BarterBackupClient_RecoverContentClient = grpc.ServerStreamingClient[RecoverContentUpdate]

func (c *barterBackupClientClient) SetAeadKeyForPeer(ctx context.Context, in *SetAeadKeyForPeerRequest, opts ...grpc.CallOption) (*SetAeadKeyForPeerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetAeadKeyForPeerResponse)
	err := c.cc.Invoke(ctx, BarterBackupClient_SetAeadKeyForPeer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *barterBackupClientClient) CliChat(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[ChatAction, ChatEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &BarterBackupClient_ServiceDesc.Streams[3], BarterBackupClient_CliChat_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ChatAction, ChatEvent]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type BarterBackupClient_CliChatClient = grpc.BidiStreamingClient[ChatAction, ChatEvent]

// BarterBackupClientServer is the server API for BarterBackupClient service.
// All implementations must embed UnimplementedBarterBackupClientServer
// for forward compatibility.
//
// BarterBackupClient is a gRPC service implemented by the BarterBackup
// daemon and exposed locally. The CLI tool speaks to the daemon using this
// protocol.
//
// Terminology:
//   - File: A user-provided file (one or more) that a client uploads to the
//     daemon. Files are inputs.
//   - Content: A single finalized encrypted blob produced by the daemon from
//     the current set of files. This is what gets backed up to peers.
type BarterBackupClientServer interface {
	// LocalHealthCheck returns success when the local daemon is healthy.
	// Renamed from HealthCheck to avoid a method name collision with bbrpc
	// on the shared Node implementation.
	LocalHealthCheck(context.Context, *HealthCheckRequest) (*HealthCheckResponse, error)
	// Unlock sends the main password to the daemon. The password is used to
	// derive the master secret key from which all other keys are derived,
	// for encryption, onion service private key, and for authentication.
	Unlock(context.Context, *UnlockRequest) (*UnlockResponse, error)
	// ConnectPeer adds the peer to the list of known peers. The daemon will
	// try to connect to it.
	ConnectPeer(context.Context, *ConnectPeerRequest) (*ConnectPeerResponse, error)
	// ConnectedPeers returns the list of connected online peers.
	ConnectedPeers(context.Context, *ConnectedPeersRequest) (*ConnectedPeersResponse, error)
	// SetFile sends a single file to the daemon. The daemon assembles a
	// single content blob from the current set of files, stores it encrypted
	// locally, and uploads the resulting content to other peers (also
	// encrypted). It stores other peers' content in exchange.
	SetFile(context.Context, *SetFileRequest) (*SetFileResponse, error)
	// GetFile returns the file data by its name from the current set of
	// files that form the most recent content blob.
	GetFile(context.Context, *GetFileRequest) (*GetFileResponse, error)
	// ListFiles returns only the names of files that form the most recent
	// content blob.
	ListFiles(context.Context, *ListFilesRequest) (*ListFilesResponse, error)
	// SetStorageConfig sets how much data of other peers we want to store
	// and what is the minimum number of replicas (peers) we want to store
	// data on. We also have obligations under old contracts (where peers are
	// offline but still have remaining time to download their data from us).
	// Given all of this it is possible to reduce the maximum content length
	// of another peer we accept into our storage.
	SetStorageConfig(context.Context, *SetStorageConfigRequest) (*SetStorageConfigResponse, error)
	// GetStorageConfig returns the current storage configuration.
	GetStorageConfig(context.Context, *GetStorageConfigRequest) (*GetStorageConfigResponse, error)
	// GetContracts returns the current state of storage contracts.
	GetContracts(context.Context, *GetContractsRequest) (*GetContractsResponse, error)
	// ProposeContract tells the server to form a contract if not already
	// present with the specified peer.
	ProposeContract(*ProposeContractRequest, grpc.ServerStreamingServer[ProposeContractUpdate]) error
	// CheckContract tells the server to check the contract with the peer.
	// It verifies that we and the peer store the most recent versions of
	// contents of each other, then downloads a random piece of our content
	// from the peer and verifies it. Such checks are also run in the
	// background.
	CheckContract(*CheckContractRequest, grpc.ServerStreamingServer[CheckContractUpdate]) error
	// RecoverContent triggers content recovery from peers. The daemon does
	// it on its own after starting and in the background. This just triggers
	// it. The stream works forever sending new recovery events.
	RecoverContent(*RecoverContentRequest, grpc.ServerStreamingServer[RecoverContentUpdate]) error
	// SetAeadKeyForPeer sets a password for symmetric encryption of chats
	// with the peer. This is an additional measure to secure communications.
	// The password has to be shared between the peers out-of-band. The key
	// derived from the password is encrypted and added to the stored content
	// so it will survive a node reset together with the main content.
	SetAeadKeyForPeer(context.Context, *SetAeadKeyForPeerRequest) (*SetAeadKeyForPeerResponse, error)
	// CliChat initiates a chat with a node. When the stream is closed, the
	// chat is ended. It uses a symmetrically encrypted chat if the AEAD key
	// is set for the node. File transfers over the chat are passed through
	// the stream.
	// Renamed from Chat to avoid a method name collision with bbrpc on the
	// shared Node implementation.
	CliChat(grpc.BidiStreamingServer[ChatAction, ChatEvent]) error
	mustEmbedUnimplementedBarterBackupClientServer()
}

// UnimplementedBarterBackupClientServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedBarterBackupClientServer struct{}

func (UnimplementedBarterBackupClientServer) LocalHealthCheck(context.Context, *HealthCheckRequest) (*HealthCheckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LocalHealthCheck not implemented")
}
func (UnimplementedBarterBackupClientServer) Unlock(context.Context, *UnlockRequest) (*UnlockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Unlock not implemented")
}
func (UnimplementedBarterBackupClientServer) ConnectPeer(context.Context, *ConnectPeerRequest) (*ConnectPeerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConnectPeer not implemented")
}
func (UnimplementedBarterBackupClientServer) ConnectedPeers(context.Context, *ConnectedPeersRequest) (*ConnectedPeersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConnectedPeers not implemented")
}
func (UnimplementedBarterBackupClientServer) SetFile(context.Context, *SetFileRequest) (*SetFileResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetFile not implemented")
}
func (UnimplementedBarterBackupClientServer) GetFile(context.Context, *GetFileRequest) (*GetFileResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFile not implemented")
}
func (UnimplementedBarterBackupClientServer) ListFiles(context.Context, *ListFilesRequest) (*ListFilesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListFiles not implemented")
}
func (UnimplementedBarterBackupClientServer) SetStorageConfig(context.Context, *SetStorageConfigRequest) (*SetStorageConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetStorageConfig not implemented")
}
func (UnimplementedBarterBackupClientServer) GetStorageConfig(context.Context, *GetStorageConfigRequest) (*GetStorageConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStorageConfig not implemented")
}
func (UnimplementedBarterBackupClientServer) GetContracts(context.Context, *GetContractsRequest) (*GetContractsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetContracts not implemented")
}
func (UnimplementedBarterBackupClientServer) ProposeContract(*ProposeContractRequest, grpc.ServerStreamingServer[ProposeContractUpdate]) error {
	return status.Errorf(codes.Unimplemented, "method ProposeContract not implemented")
}
func (UnimplementedBarterBackupClientServer) CheckContract(*CheckContractRequest, grpc.ServerStreamingServer[CheckContractUpdate]) error {
	return status.Errorf(codes.Unimplemented, "method CheckContract not implemented")
}
func (UnimplementedBarterBackupClientServer) RecoverContent(*RecoverContentRequest, grpc.ServerStreamingServer[RecoverContentUpdate]) error {
	return status.Errorf(codes.Unimplemented, "method RecoverContent not implemented")
}
func (UnimplementedBarterBackupClientServer) SetAeadKeyForPeer(context.Context, *SetAeadKeyForPeerRequest) (*SetAeadKeyForPeerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetAeadKeyForPeer not implemented")
}
func (UnimplementedBarterBackupClientServer) CliChat(grpc.BidiStreamingServer[ChatAction, ChatEvent]) error {
	return status.Errorf(codes.Unimplemented, "method CliChat not implemented")
}
func (UnimplementedBarterBackupClientServer) mustEmbedUnimplementedBarterBackupClientServer() {}
func (UnimplementedBarterBackupClientServer) testEmbeddedByValue()                            {}

// UnsafeBarterBackupClientServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BarterBackupClientServer will
// result in compilation errors.
type UnsafeBarterBackupClientServer interface {
	mustEmbedUnimplementedBarterBackupClientServer()
}

func RegisterBarterBackupClientServer(s grpc.ServiceRegistrar, srv BarterBackupClientServer) {
	// If the following call pancis, it indicates UnimplementedBarterBackupClientServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&BarterBackupClient_ServiceDesc, srv)
}

func _BarterBackupClient_LocalHealthCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HealthCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BarterBackupClientServer).LocalHealthCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BarterBackupClient_LocalHealthCheck_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BarterBackupClientServer).LocalHealthCheck(ctx, req.(*HealthCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BarterBackupClient_Unlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BarterBackupClientServer).Unlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BarterBackupClient_Unlock_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BarterBackupClientServer).Unlock(ctx, req.(*UnlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BarterBackupClient_ConnectPeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConnectPeerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BarterBackupClientServer).ConnectPeer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BarterBackupClient_ConnectPeer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BarterBackupClientServer).ConnectPeer(ctx, req.(*ConnectPeerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BarterBackupClient_ConnectedPeers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConnectedPeersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BarterBackupClientServer).ConnectedPeers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BarterBackupClient_ConnectedPeers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BarterBackupClientServer).ConnectedPeers(ctx, req.(*ConnectedPeersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BarterBackupClient_SetFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BarterBackupClientServer).SetFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BarterBackupClient_SetFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BarterBackupClientServer).SetFile(ctx, req.(*SetFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BarterBackupClient_GetFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BarterBackupClientServer).GetFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BarterBackupClient_GetFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BarterBackupClientServer).GetFile(ctx, req.(*GetFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BarterBackupClient_ListFiles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListFilesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BarterBackupClientServer).ListFiles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BarterBackupClient_ListFiles_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BarterBackupClientServer).ListFiles(ctx, req.(*ListFilesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BarterBackupClient_SetStorageConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetStorageConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BarterBackupClientServer).SetStorageConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BarterBackupClient_SetStorageConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BarterBackupClientServer).SetStorageConfig(ctx, req.(*SetStorageConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BarterBackupClient_GetStorageConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStorageConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BarterBackupClientServer).GetStorageConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BarterBackupClient_GetStorageConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BarterBackupClientServer).GetStorageConfig(ctx, req.(*GetStorageConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BarterBackupClient_GetContracts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetContractsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BarterBackupClientServer).GetContracts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BarterBackupClient_GetContracts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BarterBackupClientServer).GetContracts(ctx, req.(*GetContractsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BarterBackupClient_ProposeContract_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ProposeContractRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BarterBackupClientServer).ProposeContract(m, &grpc.GenericServerStream[ProposeContractRequest, ProposeContractUpdate]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type BarterBackupClient_ProposeContractServer = grpc.ServerStreamingServer[ProposeContractUpdate]

func _BarterBackupClient_CheckContract_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CheckContractRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BarterBackupClientServer).CheckContract(m, &grpc.GenericServerStream[CheckContractRequest, CheckContractUpdate]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type BarterBackupClient_CheckContractServer = grpc.ServerStreamingServer[CheckContractUpdate]

func _BarterBackupClient_RecoverContent_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RecoverContentRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BarterBackupClientServer).RecoverContent(m, &grpc.GenericServerStream[RecoverContentRequest, RecoverContentUpdate]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type BarterBackupClient_RecoverContentServer = grpc.ServerStreamingServer[RecoverContentUpdate]

func _BarterBackupClient_SetAeadKeyForPeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetAeadKeyForPeerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BarterBackupClientServer).SetAeadKeyForPeer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BarterBackupClient_SetAeadKeyForPeer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BarterBackupClientServer).SetAeadKeyForPeer(ctx, req.(*SetAeadKeyForPeerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BarterBackupClient_CliChat_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(BarterBackupClientServer).CliChat(&grpc.GenericServerStream[ChatAction, ChatEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type BarterBackupClient_CliChatServer = grpc.BidiStreamingServer[ChatAction, ChatEvent]

// BarterBackupClient_ServiceDesc is the grpc.ServiceDesc for BarterBackupClient service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BarterBackupClient_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "clirpc.BarterBackupClient",
	HandlerType: (*BarterBackupClientServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "LocalHealthCheck",
			Handler:    _BarterBackupClient_LocalHealthCheck_Handler,
		},
		{
			MethodName: "Unlock",
			Handler:    _BarterBackupClient_Unlock_Handler,
		},
		{
			MethodName: "ConnectPeer",
			Handler:    _BarterBackupClient_ConnectPeer_Handler,
		},
		{
			MethodName: "ConnectedPeers",
			Handler:    _BarterBackupClient_ConnectedPeers_Handler,
		},
		{
			MethodName: "SetFile",
			Handler:    _BarterBackupClient_SetFile_Handler,
		},
		{
			MethodName: "GetFile",
			Handler:    _BarterBackupClient_GetFile_Handler,
		},
		{
			MethodName: "ListFiles",
			Handler:    _BarterBackupClient_ListFiles_Handler,
		},
		{
			MethodName: "SetStorageConfig",
			Handler:    _BarterBackupClient_SetStorageConfig_Handler,
		},
		{
			MethodName: "GetStorageConfig",
			Handler:    _BarterBackupClient_GetStorageConfig_Handler,
		},
		{
			MethodName: "GetContracts",
			Handler:    _BarterBackupClient_GetContracts_Handler,
		},
		{
			MethodName: "SetAeadKeyForPeer",
			Handler:    _BarterBackupClient_SetAeadKeyForPeer_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ProposeContract",
			Handler:       _BarterBackupClient_ProposeContract_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "CheckContract",
			Handler:       _BarterBackupClient_CheckContract_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "RecoverContent",
			Handler:       _BarterBackupClient_RecoverContent_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "CliChat",
			Handler:       _BarterBackupClient_CliChat_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "clirpc/barter_backup_client.proto",
}
